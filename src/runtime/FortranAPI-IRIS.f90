MODULE IRIS
    USE ISO_C_BINDING
    USE, INTRINSIC :: ISO_C_BINDING
    IMPLICIT NONE

    TYPE, BIND(C) :: iris_mem
        TYPE(C_PTR) :: class_obj
        INTEGER(C_LONG) :: uid
    END TYPE 

    TYPE, BIND(C) :: iris_task
        TYPE(C_PTR) :: class_obj
        INTEGER(C_LONG) :: uid
    END TYPE 

    INTEGER, PARAMETER :: IRIS_SUCCESS  = 0
    INTEGER, PARAMETER :: IRIS_ERROR    = -1

    INTEGER, PARAMETER :: IRIS_CPU      = LSHIFT(1, 6)
    INTEGER, PARAMETER :: IRIS_NVIDIA   = LSHIFT(1, 7)
    INTEGER, PARAMETER :: IRIS_AMD      = LSHIFT(1, 8)
    INTEGER, PARAMETER :: IRIS_GPU      = IRIS_NVIDIA + IRIS_AMD

    INTEGER, PARAMETER :: IRIS_R        = -1
    INTEGER, PARAMETER :: IRIS_W        = -2
    INTEGER, PARAMETER :: IRIS_RW       = -3

    INTERFACE
    INTEGER(C_INT) FUNCTION IRIS_INIT_CBIND(ARGC, ARGV, SYNC) &
        BIND(C, NAME='iris_init')
        USE, INTRINSIC :: ISO_C_BINDING
        INTEGER(C_INT), VALUE, INTENT(IN) :: ARGC
        TYPE(C_PTR), VALUE, INTENT(IN) :: ARGV
        INTEGER(C_INT), VALUE, INTENT(IN) :: SYNC
    END FUNCTION IRIS_INIT_CBIND

    INTEGER(C_INT) FUNCTION IRIS_FINALIZE_CBIND() &
        BIND(C, NAME='iris_finalize')
        USE, INTRINSIC :: ISO_C_BINDING
    END FUNCTION IRIS_FINALIZE_CBIND

    INTEGER(C_INT) FUNCTION IRIS_MEM_CREATE_CBIND(SIZE, MEM_X) &
        BIND(C, NAME='iris_mem_create')
        USE, INTRINSIC :: ISO_C_BINDING
        INTEGER(C_SIZE_T), VALUE, INTENT(IN) :: SIZE
        TYPE(C_PTR), VALUE, INTENT(IN) :: MEM_X
    END FUNCTION IRIS_MEM_CREATE_CBIND

    INTEGER(C_INT) FUNCTION IRIS_TASK_CREATE_CBIND(TASK_X) &
        BIND(C, NAME='iris_task_create')
        USE, INTRINSIC :: ISO_C_BINDING
        TYPE(C_PTR), VALUE, INTENT(IN) :: TASK_X
    END FUNCTION IRIS_TASK_CREATE_CBIND

    INTEGER(C_INT) FUNCTION IRIS_TASK_H2D_FULL_CBIND(TASK_X, MEM_X, HOST_X) &
        BIND(C, NAME='iris_task_h2d_full')
        USE, INTRINSIC :: ISO_C_BINDING
        import :: iris_task
        import :: iris_mem
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        TYPE(iris_mem), VALUE, INTENT(IN):: MEM_X
        TYPE(C_PTR), VALUE, INTENT(IN) :: HOST_X
    END FUNCTION IRIS_TASK_H2D_FULL_CBIND

    INTEGER(C_INT) FUNCTION IRIS_TASK_D2H_FULL_CBIND(TASK_X, MEM_X, HOST_X) &
        BIND(C, NAME='iris_task_d2h_full')
        USE, INTRINSIC :: ISO_C_BINDING
        import :: iris_mem
        import :: iris_task
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        TYPE(iris_mem), VALUE, INTENT(IN):: MEM_X
        TYPE(C_PTR), VALUE, INTENT(IN) :: HOST_X
    END FUNCTION IRIS_TASK_D2H_FULL_CBIND

    INTEGER(C_INT) FUNCTION IRIS_TASK_KERNEL_CBIND(TASK_X, KERNEL, DIM, OFF, &
      GWS, LWS, NPARAMS, PARAMS, PARAMS_INFO) &
        BIND(C, NAME='iris_task_kernel')
        USE, INTRINSIC :: ISO_C_BINDING
        import :: iris_task
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        CHARACTER, DIMENSION(*), INTENT(IN) :: KERNEL
        INTEGER(C_INT), VALUE, INTENT(IN) :: DIM
        INTEGER(C_SIZE_T), DIMENSION(*), INTENT(IN) :: OFF
        INTEGER(C_SIZE_T), DIMENSION(*), INTENT(IN) :: GWS
        INTEGER(C_SIZE_T), DIMENSION(*), INTENT(IN) :: LWS
        INTEGER(C_INT), VALUE, INTENT(IN) :: NPARAMS
        TYPE(C_PTR), DIMENSION(*), INTENT(IN) :: PARAMS
        INTEGER(C_INT), DIMENSION(*), INTENT(IN) :: PARAMS_INFO
    END FUNCTION IRIS_TASK_KERNEL_CBIND

    INTEGER(C_INT) FUNCTION IRIS_TASK_SUBMIT_CBIND(TASK_X, DEV, OPT, SYNC) &
        BIND(C, NAME='iris_task_submit')
        USE, INTRINSIC :: ISO_C_BINDING
        import :: iris_task
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        INTEGER(C_INT), VALUE, INTENT(IN) :: DEV
        TYPE(C_PTR), VALUE, INTENT(IN) :: OPT
        INTEGER(C_INT), VALUE, INTENT(IN) :: SYNC
    END FUNCTION IRIS_TASK_SUBMIT_CBIND

    END INTERFACE

    CONTAINS

    SUBROUTINE IRIS_INIT(SYNC, IERROR)
        LOGICAL, INTENT(IN) :: SYNC
        INTEGER, INTENT(OUT) :: IERROR
        INTEGER(C_INT) :: SYNC_C
        IF (SYNC) THEN
          SYNC_C = 1
        ELSE
          SYNC_C = 0
        END IF
        IERROR = IRIS_INIT_CBIND(0, C_NULL_PTR, SYNC_C)
    END SUBROUTINE IRIS_INIT

    SUBROUTINE IRIS_FINALIZE(IERROR)
        INTEGER, INTENT(OUT) :: IERROR
        IERROR = IRIS_FINALIZE_CBIND()
    END SUBROUTINE IRIS_FINALIZE

    SUBROUTINE IRIS_MEM_CREATE(SIZE, MEM_X, IERROR)
        INTEGER(8), INTENT(IN) :: SIZE
        TYPE(C_PTR), VALUE, INTENT(IN) :: MEM_X
        INTEGER, INTENT(OUT) :: IERROR
        IERROR = IRIS_MEM_CREATE_CBIND(SIZE, MEM_X)
    END SUBROUTINE IRIS_MEM_CREATE

    SUBROUTINE IRIS_TASK_CREATE(TASK_X, IERROR)
        TYPE(C_PTR), VALUE, INTENT(IN) :: TASK_X
        INTEGER, INTENT(OUT) :: IERROR
        IERROR = IRIS_TASK_CREATE_CBIND(TASK_X)
    END SUBROUTINE IRIS_TASK_CREATE

    SUBROUTINE IRIS_TASK_H2D_FULL(TASK_X, MEM_X, HOST_X, IERROR)
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        TYPE(iris_mem), VALUE, INTENT(IN) :: MEM_X
        TYPE(C_PTR), VALUE, INTENT(IN) :: HOST_X
        INTEGER, INTENT(OUT) :: IERROR
        IERROR = IRIS_TASK_H2D_FULL_CBIND(TASK_X, MEM_X, HOST_X)
    END SUBROUTINE IRIS_TASK_H2D_FULL

    SUBROUTINE IRIS_TASK_D2H_FULL(TASK_X, MEM_X, HOST_X, IERROR)
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        TYPE(iris_mem), VALUE, INTENT(IN) :: MEM_X
        TYPE(C_PTR), VALUE, INTENT(IN) :: HOST_X
        INTEGER, INTENT(OUT) :: IERROR
        IERROR = IRIS_TASK_D2H_FULL_CBIND(TASK_X, MEM_X, HOST_X)
    END SUBROUTINE IRIS_TASK_D2H_FULL

    SUBROUTINE IRIS_TASK_KERNEL(TASK_X, KERNEL, DIM, OFF, &
      GWS, LWS, NPARAMS, PARAMS, PARAMS_INFO, IERROR)
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        CHARACTER, DIMENSION(*), INTENT(IN) :: KERNEL
        INTEGER, INTENT(IN) :: DIM
        INTEGER(8), DIMENSION(*), INTENT(IN) :: OFF
        INTEGER(8), DIMENSION(*), INTENT(IN) :: GWS
        INTEGER(8), DIMENSION(*), INTENT(IN) :: LWS
        INTEGER, INTENT(IN) :: NPARAMS
        TYPE(C_PTR), DIMENSION(*), TARGET, INTENT(IN) :: PARAMS
        INTEGER, DIMENSION(*), INTENT(IN) :: PARAMS_INFO
        INTEGER, INTENT(OUT) :: IERROR

        !INTEGER(8),DIMENSION(NPARAMS) :: NEW_PARAMS
        !INTEGER :: PI
        !INTEGER :: I
        !DO I = 1, NPARAMS
        !  PI = PARAMS_INFO(I)
        !  IF (PI == IRIS_RW .OR. PI == IRIS_R .OR. &
        !      PI == IRIS_W) THEN
        !    NEW_PARAMS(I) = PARAMS(I)
        !  ELSE
        !    NEW_PARAMS(I) = TRANSFER(C_LOC(PARAMS(I)), TASK_X)
        !  ENDIF
        !ENDDO

        IERROR = IRIS_TASK_KERNEL_CBIND(TASK_X, KERNEL, DIM, OFF, &
          GWS, LWS, NPARAMS, PARAMS, PARAMS_INFO)
    END SUBROUTINE IRIS_TASK_KERNEL

    SUBROUTINE IRIS_TASK_SUBMIT(TASK_X, DEV, SYNC, IERROR)
        TYPE(iris_task), VALUE, INTENT(IN) :: TASK_X
        INTEGER, INTENT(IN) :: DEV
        LOGICAL, INTENT(IN) :: SYNC
        INTEGER, INTENT(OUT) :: IERROR
        INTEGER :: SYNC_C
        IF (SYNC) THEN
          SYNC_C = 1
        ELSE
          SYNC_C = 0
        END IF
        IERROR = IRIS_TASK_SUBMIT_CBIND(TASK_X, DEV, C_NULL_PTR, SYNC_C)
    END SUBROUTINE IRIS_TASK_SUBMIT

END MODULE IRIS

